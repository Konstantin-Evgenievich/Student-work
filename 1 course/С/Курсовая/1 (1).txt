/*
1.	Ввод записи с произвольным номером!
2.	Вывод записи с заданным номером!
3.	Сортировка записей по заданному полю в порядке убывания или возрастания!
4.	Вывод всех записей в отсортированном порядке на экран или принтер!
5.	Сохранение всех записей в файле!
6.	Чтение записей из файла!

!Поля записи:D (название книги, кол-во страниц, цена)
!Кол - во записей: 300
Номер поля для сортировки: 3(цена)
!Выделение памяти: статически
Сортировка Возрастанию
Устройство вывода: Экран
*/

#include <iostream>
#include <string>
#include <fstream>

using namespace std;

//структура книги
struct book {
	string name = "";			//поле: название, инициализируется пустым словом
	int num = -1, price = -1;	//поля кол-ва страниц и цены, инициализируются -1, т.к. цена и кол-во страниц не могут быть отрицательными
};

/*
ПЫ.СЫ.
Обращение к полям структуры происходит через "."
т.е.
book var; ---------объявление переменной типа book (т.е. book - пользовательский новый тип данных)
var.name; ---------получение имени книги, хранящейся в var
если нужно обратиться к полям указателя, который имеет тип структуры, то к его полям обращаются через "->"
book * p;
p->name; ----------получение имени структуры, на которую указывает p
*/

//функция редактирования записи (также используется для считывания новых записей)
book * edit(book * table, int i) {
	if ((i < 0) && (i >= 300))									//Проверяется, находится ли индекс в допустимом диапазоне
	{
		cout << "Был введен неверный индекс" << endl;
		return table;											//если не находится -> выход из функции
	}
	string str;													//создание буферной строки
	cout << "Введите название книги, количество страниц, цену книги (через enter)" << endl;
	//считывание по очереди всех полей записи
	getline(cin, str);											//считываем с консоли строку
	table[i].name = str;										//загоняем ее в поле
	getline(cin, str);											//считываем с консоли строку
	table[i].num = atoi(str.c_str());							//преобразовываем ее в формат char - строки с помощью метода c_str() и 
																//полученную строку преобразуем в число с помощью функции atoi
	getline(cin, str);
	table[i].price = atoi(str.c_str());										
	return table;												//возвращается сам массив, но уже измененный
}

book * add(book * table) {
	int i;
	for (i = 0; i < 300; i++)								//перебор всех записей по очереди
		if ((table[i].name == "") && (table[i].num == -1) && (table[i].price = -1))	//если запись пусая (т.е. все ее поля имеют значения, которые были при инициализации)
			break;																	//то цикл прерывается и у нас в i хранится индекс первой попавшейся пустой записи
	if (i == 300)		//i будет равен 300 только тогда, когда во всех записях будет что-то храниться
		cout << "Таблица заполнена, пустых мест нет" << endl;
	else
		table = edit(table, i);	//если с индексом все хорошо, то редачим эту запись 
								//edit возвращает отредаченный массив, который тут сохраняется и заново возвращается
	return table;
}

//вывод записи с заданным номером
void show(book * table, int i) {
	if ((i < 0) && (i >= 300))									//Проверяется, находится ли индекс в допустимом диапазоне
	{
		cout << "Был введен неверный индекс" << endl;
		return;													//если не находится -> выход из функции
	}
	cout << " Название книги: " << table[i].name << " Количество страниц: " << table[i].num << " Цена: " << table[i].price << endl;
}

//сортировка вставками (на вход принимает указатель на первый элемент и на последний (т.е. l = left, r = right))
//сортировки сам не знаю, так что не спрашивай за них
book * sort(book * l, book * r) {
	for (book * i = l + 1; i <= r; i++) {
		book * j = i;
		while ((j > l) && ((j - 1)->price > j->price)) {

			//обмен значениями
			book swap = *(j - 1);
			*(j - 1) = *j;
			*j = swap;

			j--;
		}
	}
	return l;						//возвращаем отсортированный массив
}

//Вывод всех записей в отсортированном порядке на экран 
//ВОПРОС: надо было сортировать саму таблицу, или выводить только в отсортированном виде?
void show_table(book * table) {
	table = sort(table, table + 300 - 1);		//table + 300 -1 ---- с помощью арифметики указателей получаем указатель на 
											//последний элемент
	for (int i = 0; i < 300; i++)
		if (!((table[i].name == "") && (table[i].num == -1) && (table[i].price == -1)))
			show(table, i);						//в цикле юзаем функцию вывода конкретной записи
}

//сохранение в файл всей БД
void save(book * table) {
	ofstream output("output.txt"); //объект типа ofstream (output stream - поток вывода), который связывается с файлом output.txt
	for (int i = 0; i < 300; i++)
		output << table[i].name << "|" << table[i].num << "|" << table[i].price << "|" << endl; //поочередно заносится каждая запись
																								//одна запись - одна строка, разделитель полей - "|"
	output.close();
}

//загрузка БД из файла
book * download(book * table) {
	ifstream input("input.txt"); //объект типа ifstream (input stream - поток ввода), который связывается с файлом input.txt
	string str;
	for (int i = 0; (i < 300) && !input.eof(); i++) {   //цикл работает, пока не считает 300 строк, или не достигнет конца файла

		/*
		getline - считывает строку
		берет 3 аргумента на вход:
		поток, откуда читаем (в данному случае файл input)
		куда записываем считанное(строка)
		разделитель - до какого символа читать
		т.е. функция по очереди будет читать фрагменты, которые расположены между "|"
		*/

		getline(input, str, '|');		//считали в строку str

		/*ищем в строке str символ переноса строки с помощью метода find()
		этот метод возвращает string::npos (non-position - флаг, что не был найден символ), если не был найден этот символ*/
		if (str.find('\n') != string::npos)
			str.erase(str.find("\n"), 1);		//стираем этот символ с помощью метода erase аргументы:
												//позиция в строке, откуда стираем и кол-во символов, что нужно стереть
		table[i].name = str;					//запихнули считанную и обработанную строку в имя
		getline(input, str, '|');				//считали кол-во страниц В СТРОКОВОМ ВИДЕ
		table[i].num = atoi(str.c_str());		//atoi - преобразует из char* в int
												//т.к. она работает только с char *, то строку нужно привести к такому формату с помощью метода c_str()
		getline(input, str, '|');
		table[i].price = atoi(str.c_str());
	}
	input.close();
	return table;
}

int main() {
	setlocale(LC_ALL, "ru");
	book table[300];		//сама таблица(или база данных-без разницы) - массив структур
							//т.к. имя массива - указатель на его первый элемент, то во всех функциях прилетает и улетает указатель типа book
	for (int i = 0; i < 10; i++)
		add(table);
	show_table(table);
	system("pause");
	return 0;
}